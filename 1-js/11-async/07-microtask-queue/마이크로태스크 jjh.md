
# 마이크로태스크

프라미스 핸들러 `.then/catch/finally`는 항상 비동기적으로 실행됩니다.

## 용어 정리
### 동기적(Synchronous)
어떤 작업을 요청했을 때 그 작업이 종료될때 까지 기다린 후 다음 작업을 수행하는 방식

### 비동기적(Asynchronous)
어떤 작업을 요청했을 때 그 작업이 종료될때 까지 기다리지 않고 다른 작업을 하고 있다가, 요청했던 작업이 종료되면 그에 대한 추가 작업을 수행하는 방식

### callback
콜백 함수는 특정 함수가 끝난 다음에 어떤 작업을 진행하고 싶을 때 콜백 함수를 사용한다. 사용 방법은 특정 함수의 파라미터로 콜백 함수를 작성하여 넣어주면 된다.

### Promise
promise는 ES6 문법에서 도입된 문법으로 기존의 callback함수의 가독성을 개선시켜 나온 문법이다. promise는 두개의 파라미터를 받고 각각 성공 했을 때와 실패 했을 때를 각각 나눠 어떤 작업을 실행할지 정해주는 문법이다. 이 promise의 장점으로는 비동기 작업의 개수가 많아져도 가독성이 떨어지지 않다는 점이다. 하지만 단점으로는 오류가 발생했을 때 발생위치를 알기가 힘들고 까다로운 작업을 하기에는 무리가 있다는 점이다.

### async/await
async/await문법은 ES8 문법에서 추가된 문법인데 이는 기존의 Promise문법을 보완해서 나온 문법이다. 해당 문법을 사용하기 위해서는 반드시!!! 함수 앞부분에 async라는 키워드를 입력하여 해당 함수가 비동기 함수라는 것을 선언해줘야한다. 그런뒤 내부의 Promise의 앞부분은에 await 키워드를 사용하여 해당 작업이 끝날 때 까지 기다렸다가 다음 작업을 실행한다는 것을 알려줘야 한다. 해당 문법에서 에러가 발생을 할 때는 try/catch를 사용하여 에러를 잡아낼수있다.

프라미스가 즉시 이행되더라도 `.then/catch/finally` *아래*에 있는 코드는 이 핸들러들이 실행되기 전에 실행됩니다.

예시:

```js run
let promise = Promise.resolve();

promise.then(() => alert("프라미스 성공!"));

alert("코드 종료"); // 얼럿 창이 가장 먼저 뜹니다.
```

예시를 실행하면 '코드 종료'가 먼저, '프라미스 성공!'이 나중에 출력되는 것을 볼 수 있습니다.

프라미스는 즉시 이행상태가 되었는데도 말이죠. 뭔가 이상하네요.

왜 `.then`이 나중에 트리거 되었을까요? 그 이유에 대해 알아봅시다.

## 마이크로태스크 큐

비동기 작업을 처리하려면 적절한 관리가 필요합니다. 이를 위해 ECMA에선 `PromiseJobs`라는 내부 큐(internal queue)를 명시합니다. V8 엔진에선 이를 '마이크로태스크 큐(microtask queue)'라고 부르기 때문에 이 용어가 좀 더 선호됩니다.

[명세서](https://tc39.github.io/ecma262/#sec-jobs-and-job-queues)의 설명을 살펴봅시다.

- 마이크로태스크 큐는 먼저 들어온 작업을 먼저 실행합니다(FIFO, first-in-first-out).
- 실행할 것이 아무것도 남아있지 않을 때만 마이크로태스크 큐에 있는 작업이 실행되기 시작합니다.

요약하자면, 어떤 프라미스가 준비되었을 때 이 프라미스의 `.then/catch/finally` 핸들러가 큐에 들어간다고 생각하시면 됩니다. 이때 핸들러들은 여전히 실행되지 않습니다. 현재 코드에서 자유로운 상태가 되었을 때에서야 자바스크립트 엔진은 큐에서 작업을 꺼내 실행합니다.

위 예시에서 '코드 종료'가 먼저 출력되는 이유가 여기에 있습니다.

![](promiseQueue.svg)

프라미스 핸들러는 항상 내부 큐를 통과하게 됩니다.

여러 개의 `.then/catch/finally`를 사용해 만든 체인의 경우, 각 핸들러는 비동기적으로 실행됩니다. 큐에 들어간 핸들러 각각은 현재 코드가 완료되고, 큐에 적체된 이전 핸들러의 실행이 완료되었을 때 실행됩니다.

**그렇다면 '프라미스 성공!'을 먼저, '코드 종료'를 나중에 출력되게 하려면 어떻게 해야 할까요?** 실행 순서가 중요한 경우엔 이런 요구사항이 충족되도록 코드를 작성해야 합니다.

방법은 아주 쉽습니다. `.then`을 사용해 큐에 넣으면 됩니다.

```js run
Promise.resolve()
  .then(() => alert("프라미스 성공!"))
  .then(() => alert("코드 종료"));
```

이제 의도한 대로 순서가 변경되었습니다.

## 처리되지 못한 거부 unhandledrejection

 <info:promise-error-handling>에서 학습한 `unhandledrejection` 이벤트를 기억하고 계시나요?

이제 자바스크립트 엔진이 어떻게 처리되지 못한 거부(unhandled rejection)를 찾는지 정확히 알 수 있습니다. 

**'처리되지 못한 거부'는 마이크로태스크 큐 끝에서 프라미스 에러가 처리되지 못할 때 발생합니다.**

정상적인 경우라면 개발자는 에러가 생길 것을 대비하여 프라미스 체인에 `.catch`를 추가해 에러를 처리합니다.

```js run
let promise = Promise.reject(new Error("프라미스 실패!"));
// 마이크로태스크 큐 끝에서 프라미스 에러가 처리되지 못할 때 .catch 로 에러를 잡아 처리
*!*
promise.catch(err => alert('잡았다!'));
*/!*

// 에러가 잘 처리되었으므로 실행되지 않습니다.
window.addEventListener('unhandledrejection', event => alert(event.reason));
```

그런데 `.catch`를 추가해주는 걸 잊은 경우, 엔진은 마이크로태스크 큐가 빈 이후에 `unhandledrejection` 이벤트를 트리거 합니다.

```js run
let promise = Promise.reject(new Error("프라미스 실패!"));

// 프라미스 실패!
window.addEventListener('unhandledrejection', event => alert(event.reason));
```

그런데 만약 아래와 같이 `setTimeout`을 이용해 에러를 나중에 처리하면 어떤 일이 생길까요?

```js run
let promise = Promise.reject(new Error("프라미스 실패!"));
*!*
setTimeout(() => promise.catch(err => alert('잡았다!')), 1000);
*/!*

// Error: 프라미스 실패!
window.addEventListener('unhandledrejection', event => alert(event.reason));
```

예시를 실행하면 `프라미스 실패!`가 먼저, `잡았다!`가 나중에 출력되는 걸 확인할 수 있습니다.

마이크로태스크 큐에 대해 몰랐다면 "에러를 잡았는데도 왜 `unhandledrejection` 핸들러가 실행되는 거지?"라는 의문을 가졌을 겁니다.

`unhandledrejection`은 마이크로태스크 큐에 있는 작업 모두가 완료되었을 때 생성됩니다. 엔진은 프라미스들을 검사하고 이 중 하나라도 '거부(rejected)' 상태이면 `unhandledrejection` 핸들러를 트리거 하죠. 이로써 앞선 의문이 자연스레 해결되었습니다.

위 예시를 실행하면 `setTimeout`을 사용해 추가한 `.catch` 역시 트리거 됩니다. 다만 `.catch`는 `unhandledrejection`이 발생한 이후에 트리거 되므로 `프라미스 실패!`가 출력됩니다.

## 요약

모든 프라미스 동작은 '마이크로태스크 큐'(ES8 용어)라 불리는 내부 '프라미스 잡(promise job)' 큐에 들어가서 처리되기 때문에 프라미스 핸들링은 항상 비동기로 처리됩니다.

따라서 `.then/catch/finally` 핸들러는 항상 현재 코드가 종료되고 난 후에 호출됩니다.

어떤 코드 조각을 `.then/catch/finally`가 호출된 이후에 실행하고 싶다면 `.then`을 체인에 추가하고 이 안에 코드 조각을 넣으면 됩니다.

브라우저와 Node.js를 포함한 대부분의 자바스크립트 엔진에선 마이크로태스크가 '이벤트 루프(event loop)'와 '매크로태스크(macrotask)'와 깊은 연관 관계를 맺습니다. 이 둘은 프라미스와는 직접적인 연관성이 없기 때문에, <info:event-loop>에서 따로 다루도록 하겠습니다.


## 간단설명
콜백함수나 이벤트 핸들러를 일시 저장한다는 점에서 태스크 큐와 동일하지만 마이크로태스크큐는 태스크 큐보다 우선순위가 높습니다.즉, 이벤트 루프는 콜 스택이 비면 먼저 마이크로태스크 큐에서 대기하고 있는 함수를 가져와 실행합니다.